# dicefinder
Find numerically balanced dice.

## Usage
`<executable> <shape_name> [point_max_stdev [face_max_stdev]]`

- `shape_name`: Die to process. Can be `hexahedron`/`d6`, `octahedron`/`d8`, `pent_trapezohedron`/`d10`, `dodecahedron`/`d12`, `icosahedron`/`d20`.
- `point_max_stdev` and `face_max_stdev`: Maximum accepted population standard deviation for point/face weights respectively. You can omit these if you really want every layout saved. The d20 will be tens of millions of bad layouts though.

The output _will_ include mirrored layouts, however it will _not_ include rotated layouts. '1' will always be the value on the zeroth face.

## Included Dice
All the 'DnD Dice' are included, except for the tetrahedron/d4 (see limitations). The unwrapping of these is a spiral peel, shown below with face indices:
![layouts](doc/layouts.webp)

## Limitations
- This project assumes classical dice where each pair of opposing sides gives the same sum; i.e. 1+6, 2+5, 3+4. That also means dice with a vertex pointing up (like the d4) aren't supported.
- Right now there is nothing like an automated importer, all shapes are compiled in. If you do want to add one yourself, you will have to add a `sparse_topology` manually. See `prototypes.hpp` for examples.
- All dice are numbered starting with, and incrementing by, 1. However, starting at a different number wouldn't actually change the distribution, and changing the increment would only scale it. You can just offset the face values generated by what you want.
